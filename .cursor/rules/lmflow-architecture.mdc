---
description: 
globs: 
alwaysApply: true
---
LMFlow Architecture & Design Patterns

Core Architecture
	1.	Modular Design: LMFlow uses a clear modular structure:
	▫	‎⁠src/lmflow/models/⁠: Model implementations, supporting HuggingFace models.
	▫	‎⁠src/lmflow/datasets/⁠: Data processing, for uni- and multi-modal data.
	▫	‎⁠src/lmflow/pipeline/⁠: Training/inference pipelines, supporting various fine-tuning strategies.
	▫	‎⁠src/lmflow/utils/⁠: Utility functions.
	2.	Design Patterns:
	▫	Factory Pattern: Used in ‎⁠auto_model.py⁠, ‎⁠auto_pipeline.py⁠ for component selection.
	▫	Template Pattern: Base classes (‎⁠base_model.py⁠, ‎⁠base_pipeline.py⁠) define interfaces.
	▫	Strategy Pattern: Fine-tuning strategies (DoRA, LoRA, DPO) are interchangeable.

Code Organization
	1.	Inheritance: All models inherit from base classes to ensure consistent interfaces.
	2.	Config-Driven: Training parameters are controlled via YAML/JSON configs, not hardcoded.
	3.	Pluggability: New fine-tuning strategies are added as plugins without disrupting existing structure.

File Naming Conventions
	1.	Model Files: Named by function, e.g., ‎⁠hf_decoder_model.py⁠, ‎⁠vision2seq_model.py⁠.
	2.	Pipeline Files: Named by task, e.g., ‎⁠finetuner.py⁠, ‎⁠evaluator.py⁠, ‎⁠inferencer.py⁠.
	3.	Config Files: Located in ‎⁠configs/⁠, clearly indicating purpose and parameters, e.g., ‎⁠ds_config_zero3.json⁠.

New Feature Development
	1.	Add Models: Create in ‎⁠models/⁠, inherit from the appropriate base class.
	2.	Add Pipelines: Create in ‎⁠pipeline/⁠, implement standard interfaces.
	3.	Add Datasets: Extend in ‎⁠datasets/⁠, support unified data format.
	4.	Add Configs: Place in ‎⁠configs/⁠, follow existing naming conventions.

Performance & Scalability
	1.	Distributed Support: DeepSpeed distributed training is supported by default.
	2.	Memory Optimization: Supports ZeRO strategies and offloading.
	3.	Component Decoupling: Loose coupling allows independent testing and maintenance.

Analogy: LMFlow’s architecture is like a well-organized factory assembly line—each station (module) performs a specific task, and design patterns serve as blueprints ensuring every part fits and can be swapped or upgraded without halting the entire operation.